import { createContext, useContext, useState } from "react";

const TripContext = createContext();

import calgaryImg from '../assets/calgary.jpg';
import raptorsImg from '../assets/Raptors.jpg';
import vancouverImg from '../assets/vancouver.jpg';
import edmontonImg from '../assets/edmonton.jpg';

export function TripProvider({ children }) {
  // Initialize with sample data
  const [trips, setTrips] = useState([
    {
      id: 1,
      name: "Holidays in YYC!",
      startDate: "Dec. 22, 2025",
      endDate: "Dec. 27, 2025",
      image: calgaryImg,
      destinations: [
        {
          id: 1,
          location: "Calgary, AB, Canada",
          arrivalDate: "2025-12-22",
          departureDate: "2025-12-27"
        }
      ],
      planners: ["Person 1", "Person 2", "Person 3"],
      viewers: ["Person 4", "Person 5"],
      status: "current", // "current", "upcoming", "past"
      canEdit: true
    },
    {
      id: 2,
      name: "Toronto",
      startDate: "Dec. 22, 2026",
      endDate: "Dec. 27, 2026",
      image: raptorsImg,
      destinations: [
        {
          id: 1,
          location: "Toronto, ON, Canada",
          arrivalDate: "2026-12-22",
          departureDate: "2026-12-27"
        }
      ],
      planners: ["Person 1"],
      viewers: ["Person 2", "Person 3"],
      status: "upcoming",
      canEdit: false
    },
    {
      id: 5,
      name: "Summer in Vancouver!",
      startDate: "Dec. 22, 2024",
      endDate: "Dec. 27, 2024",
      image: vancouverImg,
      destinations: [
        {
          id: 1,
          location: "Vancouver, BC, Canada",
          arrivalDate: "2024-12-22",
          departureDate: "2024-12-27"
        }
      ],
      planners: ["Person 1", "Person 2"],
      viewers: ["Person 3"],
      status: "past",
      canEdit: false
    },
    {
      id: 6,
      name: "Deadmonton... Again?",
      startDate: "Dec. 22, 2023",
      endDate: "Dec. 27, 2023",
      image: edmontonImg,
      destinations: [
        {
          id: 1,
          location: "Edmonton, AB, Canada",
          arrivalDate: "2023-12-22",
          departureDate: "2023-12-27"
        }
      ],
      planners: ["Person 1"],
      viewers: [],
      status: "past",
      canEdit: true
    }
  ]);

  // Helper function to format date from yyyy-mm-dd to "Mon. DD, YYYY"
  const formatDate = (dateString) => {
    const date = new Date(dateString);
    const months = ["Jan.", "Feb.", "Mar.", "Apr.", "May", "June", "July", "Aug.", "Sept.", "Oct.", "Nov.", "Dec."];
    return `${months[date.getMonth()]} ${date.getDate()}, ${date.getFullYear()}`;
  };

  // Helper function to determine trip status based on dates
  const determineStatus = (startDate, endDate) => {
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const start = new Date(startDate);
    const end = new Date(endDate);
    
    if (start <= today && end >= today) {
      return "current";
    } else if (end < today) {
      return "past";
    } else {
      return "upcoming";
    }
  };

  // Add a new trip
  const addTrip = (tripData) => {
    const { destinations, planners, viewers, name, image } = tripData;
    
    // Get the first and last dates from destinations
    const dates = destinations
      .filter(d => d.arrivalDate || d.departureDate)
      .flatMap(d => [d.arrivalDate, d.departureDate])
      .filter(Boolean)
      .sort();
    
    const startDate = dates[0] || "";
    const endDate = dates[dates.length - 1] || "";
    
    // Generate trip name from first destination if not provided
    const firstDestination = destinations[0]?.location || "New Trip";
    const autoGeneratedName = firstDestination.split(',')[0] || "New Trip";
    const tripName = name || autoGeneratedName;
    
    // Determine status based on dates
    const status = determineStatus(startDate, endDate);
    
    const newTrip = {
      id: Date.now(),
      name: tripName,
      startDate: formatDate(startDate),
      endDate: formatDate(endDate),
      image: image || null,
      destinations: destinations.map(d => ({ ...d })),
      planners: [...planners],
      viewers: [...viewers],
      status,
      canEdit: true
    };
    
    setTrips(prev => [...prev, newTrip]);
    return newTrip.id;
  };

  // Update an existing trip
  const updateTrip = (tripId, tripData) => {
    const { destinations, planners, viewers, name, image } = tripData;
    
    // Get the first and last dates from destinations
    const dates = destinations
      .filter(d => d.arrivalDate || d.departureDate)
      .flatMap(d => [d.arrivalDate, d.departureDate])
      .filter(Boolean)
      .sort();
    
    const startDate = dates[0] || "";
    const endDate = dates[dates.length - 1] || "";
    
    // Generate trip name from first destination if not provided
    const firstDestination = destinations[0]?.location || "Updated Trip";
    const autoGeneratedName = firstDestination.split(',')[0] || "Updated Trip";
    const tripName = name || autoGeneratedName;
    
    // Determine status based on dates
    const status = determineStatus(startDate, endDate);
    
    setTrips(prev => prev.map(trip => 
      trip.id === tripId 
        ? {
            ...trip,
            name: tripName,
            startDate: formatDate(startDate),
            endDate: formatDate(endDate),
            image: image !== undefined ? image : trip.image,
            destinations: destinations.map(d => ({ ...d })),
            planners: [...planners],
            viewers: [...viewers],
            status
          }
        : trip
    ));
  };

  // Delete a trip
  const deleteTrip = (tripId) => {
    setTrips(prev => prev.filter(trip => trip.id !== tripId));
  };

  // Get trip by ID
  const getTripById = (tripId) => {
    return trips.find(trip => trip.id === parseInt(tripId));
  };

  // Get categorized trips - first trip is always current, rest are sorted by date
  const getCategorizedTrips = () => {
    if (trips.length === 0) {
      return { currentTrip: null, upcomingTrips: [], pastTrips: [] };
    }
    
    // First trip is always current
    const currentTrip = trips[0];
    
    // Sort remaining trips by their start date
    const remainingTrips = trips.slice(1).sort((a, b) => {
      const dateA = new Date(a.destinations[0]?.arrivalDate || 0);
      const dateB = new Date(b.destinations[0]?.arrivalDate || 0);
      return dateB - dateA; // Descending order (newest first)
    });
    
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    // Categorize remaining trips
    const upcomingTrips = [];
    const pastTrips = [];
    
    remainingTrips.forEach(trip => {
      const tripEndDate = new Date(trip.destinations[trip.destinations.length - 1]?.departureDate || 0);
      if (tripEndDate < today) {
        pastTrips.push(trip);
      } else {
        upcomingTrips.push(trip);
      }
    });
    
    return { currentTrip, upcomingTrips, pastTrips };
  };

  return (
    <TripContext.Provider value={{
      trips,
      addTrip,
      updateTrip,
      deleteTrip,
      getTripById,
      getCategorizedTrips
    }}>
      {children}
    </TripContext.Provider>
  );
}

export function useTrips() {
  const context = useContext(TripContext);
  if (!context) {
    throw new Error("useTrips must be used within a TripProvider");
  }
  return context;
}